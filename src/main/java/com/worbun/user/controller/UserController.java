package com.worbun.user.controller;import com.worbun.user.dto.*;import com.worbun.user.dto.users.UserDTO;import com.worbun.user.dto.users.UserMapper;import com.worbun.user.exception.ResourceNotFoundException;import com.worbun.user.exception.ValidationException;import com.worbun.user.model.User;import com.worbun.user.repository.UserRepository;import com.worbun.user.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpStatus;import org.springframework.http.MediaType;import org.springframework.http.ResponseEntity;import org.springframework.transaction.annotation.Transactional;import org.springframework.web.bind.annotation.*;import org.springframework.web.multipart.MaxUploadSizeExceededException;import org.springframework.web.multipart.MultipartFile;import reactor.core.publisher.Mono;import javax.sql.rowset.serial.SerialBlob;import javax.sql.rowset.serial.SerialException;import java.io.IOException;import java.sql.Blob;import java.sql.SQLException;import java.util.List;import java.util.stream.Collectors;@CrossOrigin(origins = "*")@RestController@RequestMapping("/api/rumba/v1/users")public class UserController {    @Autowired    private UserService userService;    private final UserRepository userRepository;    public UserController(UserRepository userRepository) {        this.userRepository = userRepository;    }    @Transactional(readOnly = true)    @GetMapping    public ResponseEntity<List<UserDTO>> getAllUsers() {        List<User> users = userService.getAllUsers();        List<UserDTO> userDTOs = users.stream()                .map(UserMapper::fromUser)  // Utiliza el método estático fromUser                .collect(Collectors.toList());        return ResponseEntity.ok(userDTOs);    }    // URL: http://localhost:8081/api/thebigfun/v1/users/{userId}    // Method: GET    @Transactional(readOnly = true)    @GetMapping("/{id}")    public ResponseEntity<UserDTO> getUserById(@PathVariable Long id) {        User user = userService.getUserById(id);        if (user == null) {            return ResponseEntity.notFound().build();        }        UserDTO response = UserMapper.fromUser(user);        return ResponseEntity.status(HttpStatus.OK).body(response);    }    // URL: http://localhost:8081/api/rumba/v1/users/{userId}/image    // Method: GET    @Transactional    @GetMapping("/{userId}/image")    public ResponseEntity<byte[]> displayImage(@PathVariable(name= "userId")Long userId)throws IOException, SQLException {        User user = userService.getUserById(userId);        byte[] imageBytes = null;        imageBytes = user.getImage().getBytes(1,(int)user.getImage().length());        return ResponseEntity.ok().contentType(MediaType.IMAGE_PNG).body(imageBytes);    }    // URL: http://localhost:8081/api/rumba/v1/users/{userId}/addImage    // Method: POST    @Transactional    @PostMapping("/{userId}/addImage")    public ResponseEntity<UserDTO> addImageUser(@PathVariable Long userId,                                                @RequestParam("image") MultipartFile imageFile) {        try {            // Converti MultipartFile a Blob            Blob imageBlob = multipartFileToBlob(imageFile);            if (imageBlob == null) {                // Manejamos en el caso en que la conversión falle                return ResponseEntity.status(HttpStatus.BAD_REQUEST).body(null);            }            User user = userService.getUserById(userId);            if (user == null) {                // Usuario no encontrado                return ResponseEntity.status(HttpStatus.NOT_FOUND).body(null);            }            user.setImage(imageBlob);            User updatedUser = userService.updateUser(user);            return ResponseEntity.ok(convertToDto(updatedUser));        } catch (Exception e) {            // Manejar otras excepciones            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(null);        }    }    private Blob multipartFileToBlob(MultipartFile file) throws IOException, SerialException, SQLException {        byte[] bytes = file.getBytes();        return new SerialBlob(bytes);    }    // Manejar el peso para agregar un imagen    @ControllerAdvice    public class FileUploadExceptionAdvice {        @ExceptionHandler(MaxUploadSizeExceededException.class)        public ResponseEntity<String> handleMaxSizeException(MaxUploadSizeExceededException exc) {            return ResponseEntity.status(HttpStatus.EXPECTATION_FAILED).body("No se puede cargar el archivo. Tamaño máximo permitido excedido.");        }    }    // URL: http://localhost:8081/api/thebigfun/v1/users/{userId}    // Method: PUT    @Transactional    @PutMapping("/{userId}")    public ResponseEntity<UserDTO> updateUser(@PathVariable(name = "userId") Long userId, @RequestBody User user) {        existsUserByUserId(userId);        validateUser(user);        user.setId(userId);        User updateUser = ifDifferentOrEmptyUpdate(user);        UserDTO userDTO = UserMapper.fromUser(updateUser);        return ResponseEntity.ok(userDTO);    }    // URL: http://localhost:8081/api/rumba/v1/users/{userId}    // Method: DELETE    @Transactional    @DeleteMapping("/{userId}")    public ResponseEntity<Void> deleteUser(@PathVariable(name = "userId") Long userId) {        existsUserByUserId(userId);        userService.deleteUser(userId);        return new ResponseEntity<Void>(HttpStatus.NO_CONTENT);    }    // URL: http://localhost:8080/api/rumba/v1/users/{userId}/events    // Method: LISTA eventos del usuario    @GetMapping("/{userId}/events")    public Mono<ResponseEntity<EventAndUserDTO>> getUserAndEvents(@PathVariable Long userId) {        return userService.getUserAndEventsById(userId)                .map(eventAndUser -> ResponseEntity.ok(eventAndUser))                .defaultIfEmpty(ResponseEntity.notFound().build());    }///api/bookings_services/bookings/byUser/{userId}"    ///api/rumba/v1/users/    //http://localhost:8080/api/rumba/v1/users/4/events-bookings    // Endpoint para obtener los datos combinados de usuarios, eventos y reservas    @GetMapping("/{userId}/events-bookings")    public Mono<ResponseEntity<UserEventAndBookingDTO>> getUserEventAndBookings(@PathVariable Long userId) {        return userService.getUserEventAndBookingsById(userId)                .map(userEventAndBookingDTO -> ResponseEntity.ok(userEventAndBookingDTO))                .defaultIfEmpty(ResponseEntity.notFound().build());    }    // Nuevo endpoint para obtener detalles de usuario, eventos y reservas    @GetMapping("/{userId}/details")    public Mono<ResponseEntity<UserEventAndBookingDTO>> getUserDetails(@PathVariable Long userId) {        return userService.getUserEventAndBookingsById(userId)                .map(userEventAndBookingDTO -> ResponseEntity.ok(userEventAndBookingDTO))                .defaultIfEmpty(ResponseEntity.notFound().build());    }    private UserDTO convertToDto(User user) {        return UserDTO.builder()                .id(user.getId())                .userFirstName(user.getUserFirstName())                .userLastName(user.getUserLastName())                .userEmail(user.getUserEmail())                .userPhone(user.getUserPhone())                .imageData(user.getImageData())                .build();    }    private void validateUser(User user) {        if (user.getUserFirstName() == null || user.getUserFirstName().isEmpty()) {            throw new ValidationException("El nombre del usuario debe ser obligatorio");        }        if (user.getUserFirstName().length() > 50) {            throw new ValidationException("El nombre del usuario no debe exceder los 50 caracteres");        }        if (user.getUserLastName() == null || user.getUserLastName().isEmpty()) {            throw new ValidationException("El apellido del usuario debe ser obligatorio");        }        if (user.getUserLastName().length() > 50) {            throw new ValidationException("El apellido del usuario no debe exceder los 50 caracteres");        }        /*if (user.getUserEmail() == null || user.getUserEmail().isEmpty()) {            throw new ValidationException("El email del usuario debe ser obligatorio");        }        if (user.getUserEmail().length() > 50) {            throw new ValidationException("El email del usuario no debe exceder los 50 caracteres");        }        //if (user.getUserPassword() == null || user.getUserPassword().isEmpty()) {            throw new ValidationException("La contraseña del usuario debe ser obligatorio");        }        if (user.getUserPassword().length() > 100) {            throw new ValidationException("La contraseña del usuario no debe exceder los 100 caracteres");        }*/    }    private void existsUserByEmail(User user) {        if (userRepository.existsByUserEmail(user.getUserEmail())) {            throw new ValidationException("Ya existe un usuario con el email " + user.getUserEmail());        }    }    private void existsUserByEmail(String email) {        if (!userRepository.existsByUserEmail(email)) {            throw new ResourceNotFoundException("No existe un usuario con el email " + email);        }    }    private void existsUserByUserId(Long userId) {        if (userService.getUserById(userId) == null) {            throw new ResourceNotFoundException("No existe un usuario con el id " + userId);        }    }    private User ifDifferentOrEmptyUpdate(User user) {        return userRepository.findById(user.getId()).map(userToUpdate -> {            if (user.getUserFirstName() != null && !user.getUserFirstName().isEmpty() && !user.getUserFirstName().equals(userToUpdate.getUserFirstName())) {                userToUpdate.setUserFirstName(user.getUserFirstName());            }            if (user.getUserLastName() != null && !user.getUserLastName().isEmpty() && !user.getUserLastName().equals(userToUpdate.getUserLastName())) {                userToUpdate.setUserLastName(user.getUserLastName());            }            if (user.getUserEmail() != null && !user.getUserEmail().isEmpty() && !user.getUserEmail().equals(userToUpdate.getUserEmail())) {                userToUpdate.setUserEmail(user.getUserEmail());            }            if (user.getUserPhone() != null && !user.getUserPhone().isEmpty() && !user.getUserPhone().equals(userToUpdate.getUserPhone())) {                userToUpdate.setUserPhone(user.getUserPhone());            }            if (user.getImageData() != null && !user.getImageData().isEmpty() && !user.getImageData().equals(userToUpdate.getImageData())) {                userToUpdate.setImageData(user.getImageData());            }           // Aquí agregamos la lógica para actualizar el rol si es diferente solo el admin puede cambiar            if (user.getRole() != null && !user.getRole().equals(userToUpdate.getRole())) {                userToUpdate.setRole(user.getRole());            }            return userService.updateUser(userToUpdate);        }).orElseThrow(() -> new ResourceNotFoundException("User not found with id " + user.getId()));    }//    @GetMapping("/{id}/ethereum-address")//    public ResponseEntity<String> getEthereumAddress(@PathVariable Long id) {//        User user = userRepository.findById(id)//                .orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Usuario no encontrado"));//        return ResponseEntity.ok(user.getEthereumAddress());//    }}