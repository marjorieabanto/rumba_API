package com.worbun.user.service.impl;import com.worbun.user.dto.UserEventAndBookingDTO;import com.worbun.user.dto.bookings.BookingDTO;import com.worbun.user.dto.users.UserDTO;import org.springframework.http.HttpStatus;import org.springframework.web.server.ResponseStatusException;import com.worbun.user.dto.EventAndUserDTO;import com.worbun.user.dto.events.EventDTO;import com.worbun.user.model.Roles;import com.worbun.user.model.User;import com.worbun.user.repository.UserRepository;import com.worbun.user.service.UserService;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.beans.factory.annotation.Value;import org.springframework.stereotype.Service;import org.springframework.web.reactive.function.client.WebClient;import reactor.core.publisher.Mono;import java.time.LocalDate;import java.util.ArrayList;import java.util.List;@Servicepublic class UserServiceImpl implements UserService {    @Autowired    private CouponServiceImpl couponService;    private UserRepository userRepository;    private final WebClient.Builder webClientBuilder;    private final WebClient webClient;    @Value("${api.gateway.base.url}")    private String apiGatewayBaseUrl;    @Autowired    public UserServiceImpl(UserRepository userRepository, WebClient.Builder webClientBuilder) {        this.userRepository = userRepository;        this.webClientBuilder = webClientBuilder; // Guardar el builder para usos futuros.        this.webClient = webClientBuilder.baseUrl(apiGatewayBaseUrl).build(); // Configurar una instancia de WebClient con la URL base.    }    @Override    public User createUser(User user) {        if (user.getCouponCode() != null && couponService.validateCoupon(user.getCouponCode())) {            activateFreeTrial(user, 30);  // Activar una prueba gratuita de 30 días        }        return userRepository.save(user);    }    public void activateFreeTrial(User user, int days) {        user.setTrialExpiryDate(LocalDate.now().plusDays(days));        userRepository.save(user);    }    @Override    public User getUserById(Long user_id) {        return userRepository.findById(user_id).orElse(null);    }    @Override    public User updateUser(User user) {        return userRepository.save(user);    }    @Override    public void deleteUser(Long user_id) {        userRepository.deleteById(user_id);    }    @Override    public List<User> getAllUsers() {        return userRepository.findAll();    }    public boolean existsUserByUserId(Long userId) {        return userRepository.existsById(userId);    }    // Verificar el estado de la suscripción o prueba gratuita    public boolean hasActiveSubscription(Long userId) {        User user = userRepository.findById(userId).orElseThrow(() -> new ResponseStatusException(HttpStatus.NOT_FOUND, "Usuario no encontrado"));        return user.isHasActiveSubscription() || LocalDate.now().isBefore(user.getTrialExpiryDate());    }    /*    @Override    public Mono<EventAndUserDTO> getUserDetailsWithEventCount(Long user_id) {// Obtener detalles del usuario        Mono<UserDTO> userMono = webClientBuilder.build()                .get()                .uri(apiGatewayBaseUrl + "/api/user_services/users/{userId}", user_id)                .retrieve()                .bodyToMono(UserDTO.class);        // Obtener la cuenta de eventos organizados por el usuario        Mono<Integer> eventCountMono = webClientBuilder.build()                .get()                .uri(apiGatewayBaseUrl + "/api/event_services/events/count/byOrganizer/{organizerId}", user_id)                .retrieve()                .bodyToMono(Integer.class);  // Asume que hay un endpoint que retorna el conteo directamente        // Combinar los resultados        return Mono.zip(userMono, eventCountMono, UserEventCountDTO::new);    }*/    // URL: //localhost:8080/api/event_services/events/byOrganizer/4    // Method: Lista eventos de Organizador con el ID    public Mono<List<EventDTO>> getEventsByOrganizerId(Long organizerId) {        // Convierte el Optional<User> a Mono<User>        return Mono.justOrEmpty(userRepository.findById(organizerId))                .flatMap(user -> {                    if (Roles.DJ.equals(user.getRole())) {                        // Continúa con el flujo si el usuario es un organizador                        return webClientBuilder.build()                                .get()                                .uri(apiGatewayBaseUrl + "/api/event_services/events/byOrganizer/" + organizerId)                                .retrieve()                                .bodyToFlux(EventDTO.class)                                .collectList();                    } else {                        // Devuelve un error si el usuario no es un organizador                        return Mono.error(new ResponseStatusException(HttpStatus.FORBIDDEN, "El usuario no tiene el rol de organizador"));                    }                })                .switchIfEmpty(Mono.error(new ResponseStatusException(HttpStatus.NOT_FOUND, "Usuario no encontrado")));    }    // URL: http://localhost:8080/api/thebigfun/v1/users/{userId}/events    // Method: LISTA eventos del usuario    @Override    public Mono<EventAndUserDTO> getUserAndEventsById(Long user_id) {        Mono<UserDTO> userMono = webClient.get()                .uri(apiGatewayBaseUrl + "/api/thebigfun/v1/users/{userId}", user_id)                .retrieve()                .bodyToMono(UserDTO.class)                .onErrorResume(e -> Mono.empty());  // Maneja el error para continuar        Mono<List<EventDTO>> eventsMono = webClient.get()                .uri(apiGatewayBaseUrl + "/api/event_services/events/byOrganizer/{organizerId}", user_id)                .retrieve()                .bodyToFlux(EventDTO.class)                .collectList()                .onErrorResume(e -> Mono.just(new ArrayList<>()));  // Maneja el error para continuar        return Mono.zip(userMono, eventsMono, EventAndUserDTO::new)                .filter(eventAndUserDTO -> eventAndUserDTO.getUser() != null);  // Filtra para asegurar que el usuario no sea nulo    }    @Override    public Mono<UserEventAndBookingDTO> getUserEventAndBookingsById(Long user_id) {        Mono<UserDTO> userMono = webClient.get()                .uri(apiGatewayBaseUrl + "/api/thebigfun/v1/users/{userId}", user_id)                .retrieve()                .bodyToMono(UserDTO.class)                .onErrorResume(e -> Mono.empty());  // Maneja el error para continuar        Mono<List<EventDTO>> eventsMono = webClient.get()                .uri(apiGatewayBaseUrl + "/api/event_services/events/byOrganizer/{organizerId}", user_id)                .retrieve()                .bodyToFlux(EventDTO.class)                .collectList()                .onErrorResume(e -> Mono.just(new ArrayList<>()));  // Maneja el error para continuar        Mono<List<BookingDTO>> bookingsMono = webClient.get()                .uri(apiGatewayBaseUrl + "/api/bookings_services/bookings/byUser/{userId}", user_id)                .retrieve()                .bodyToFlux(BookingDTO.class)                .collectList()                .onErrorResume(e -> Mono.just(new ArrayList<>()));  // Maneja el error para continuar        return Mono.zip(userMono, eventsMono, bookingsMono)                .map(tuple -> {                    UserDTO user = tuple.getT1();                    List<EventDTO> events = tuple.getT2();                    List<BookingDTO> bookings = tuple.getT3();                    return new UserEventAndBookingDTO(user, events, bookings);                })                .filter(userEventAndBookingDTO -> userEventAndBookingDTO.getUser() != null);    }}