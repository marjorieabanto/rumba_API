package com.worbun.user.service.impl;import com.fasterxml.jackson.databind.ObjectMapper;import com.worbun.user.dto.AuthenticationResponse;import com.worbun.user.dto.LoginRequest;import com.worbun.user.dto.RegisterRequest;import com.worbun.user.exception.ValidationException;import com.worbun.user.model.Roles;import com.worbun.user.model.Token;import com.worbun.user.model.TokenType;import com.worbun.user.model.User;import com.worbun.user.repository.TokenRepository;import com.worbun.user.repository.UserRepository;import com.worbun.user.service.AuthService;import com.worbun.user.service.EmailService;import com.worbun.user.service.JwtService;import jakarta.servlet.http.HttpServletRequest;import jakarta.servlet.http.HttpServletResponse;import lombok.RequiredArgsConstructor;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.http.HttpHeaders;import org.springframework.security.authentication.AuthenticationManager;import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;import org.springframework.security.crypto.password.PasswordEncoder;import org.springframework.stereotype.Service;import org.web3j.crypto.ECKeyPair;import org.web3j.crypto.Keys;import java.io.IOException;import java.security.InvalidAlgorithmParameterException;import java.security.NoSuchAlgorithmException;import java.security.NoSuchProviderException;import java.security.SecureRandom;import java.time.LocalDate;import java.util.EnumSet;@Service@RequiredArgsConstructorpublic class AuthServiceImp implements AuthService {    @Autowired    private UserRepository userRepository;    @Autowired    private CouponServiceImpl couponService;    @Autowired    private TokenRepository tokenRepository;    @Autowired    private EmailService emailService;    private final JwtService jwtService;    private final PasswordEncoder passwordEncoder;    private final AuthenticationManager authenticationManager;    private SecureRandom random = new SecureRandom();    private void validateRole(Roles role) {        // EnumSet de roles permitidos para autoasignarse        EnumSet<Roles> allowedRoles = EnumSet.of(Roles.USER, Roles. DJ, Roles .ADMIN);        if (!allowedRoles.contains(role)) {            throw new ValidationException("Asignación de rol no permitida.");        }    }    @Override    public AuthenticationResponse register(RegisterRequest registerRequest) {        //Aqui vamos a  validar rol antes de asignarlo        validateRole(registerRequest.getRole());        // Generar una clave privada y dirección Ethereum        ECKeyPair keyPair;        try {            keyPair = Keys.createEcKeyPair();        } catch (InvalidAlgorithmParameterException | NoSuchAlgorithmException | NoSuchProviderException e) {            throw new RuntimeException("Error al generar la clave Ethereum", e);        }        String privateKey = keyPair.getPrivateKey().toString(16);        String ethereumAddress = "0x" + Keys.getAddress(keyPair);        var user = User.builder()                .userFirstName(registerRequest.getUserFirstName())                .userLastName(registerRequest.getUserLastName())                .userEmail(registerRequest.getUserEmail())                .userPassword(passwordEncoder.encode(registerRequest.getUserPassword()))                .userPhone(registerRequest.getUserPhone())                .imageData(registerRequest.getImageData())                //.role(Roles.USER)                .role(registerRequest.getRole())//Usa el rol del request despues de validar                //.ethereumAddress(ethereumAddress)                //.privateKey(privateKey)                .build();        if (registerRequest.getCouponCode() != null && !registerRequest.getCouponCode().isEmpty()) {            boolean isCouponValid = couponService.validateCoupon(registerRequest.getCouponCode());            if (isCouponValid) {                // Si el cupón es válido, activar un periodo de prueba de 30 días                user.setTrialExpiryDate(LocalDate.now().plusDays(30));                user.setCouponCode(registerRequest.getCouponCode());            } else {                throw new ValidationException("El cupón proporcionado no es válido.");            }        } else {            // Si no hay cupón, asignar 1 día de prueba gratuita            user.setTrialExpiryDate(LocalDate.now().plusDays(1));        }        var savedUser = userRepository. save(user);        var jwtToken = jwtService.generateToken(user);        var refreshToken = jwtService.generateRefreshToken(user);        saveUserToken(savedUser, jwtToken);        return AuthenticationResponse.builder()                .user_id(user.getId())                .accessToken(jwtToken)                .refreshToken(refreshToken)                .build();    }    @Override    public AuthenticationResponse login(LoginRequest loginRequest) {        authenticationManager.authenticate(                new UsernamePasswordAuthenticationToken(                        loginRequest.getUserEmail(),                        loginRequest.getUserPassword()));        var user = userRepository.findByUserEmail(loginRequest.getUserEmail());        boolean isSubscribed = user.isHasActiveSubscription();        boolean isOnTrial = LocalDate.now().isBefore(user.getTrialExpiryDate());        if (!isSubscribed && !isOnTrial) {            throw new ValidationException("No tienes una suscripción activa o periodo de prueba.");        }        var jwtToken = jwtService.generateToken(user);        var refreshToken = jwtService.generateRefreshToken(user);        revokeAllUserTokens(user);        saveUserToken(user, jwtToken);        return AuthenticationResponse.builder()                .user_id(user.getId())                .accessToken(jwtToken)                .refreshToken(refreshToken)                .build();    }    @Override    public void refreshToken(HttpServletRequest request, HttpServletResponse response) throws IOException {        final String authHeader = request.getHeader(HttpHeaders.AUTHORIZATION);        final String refreshToken;        final String userEmail;        if (authHeader == null || !authHeader.startsWith("Bearer ")) {            return;        }        refreshToken = authHeader.substring(7);        userEmail = jwtService.extractUsername(refreshToken);        if (userEmail != null) {            var user = this.userRepository.findByUserEmail(userEmail);            if (jwtService.isTokenValid(refreshToken, user)) {                var accessToken = jwtService.generateToken(user);                revokeAllUserTokens(user);                saveUserToken(user, accessToken);                var authResponse = AuthenticationResponse.builder()                        .accessToken(accessToken)                        .refreshToken(refreshToken)                        .build();                new ObjectMapper().writeValue(response.getOutputStream(), authResponse);            }        }    }    private void saveUserToken(User user, String jwtToken) {        var token = Token.builder()                .user(user)                .token(jwtToken)                .tokenType(TokenType.BEARER)                .expired(false)                .revoked(false)                .build();        tokenRepository.save(token);    }    private void revokeAllUserTokens(User user) {        var validUserTokens = tokenRepository.findAllValidTokenByUser(user.getId());        if (validUserTokens.isEmpty())            return;        validUserTokens.forEach(token -> {            token.setExpired(true);            token.setRevoked(true);        });        tokenRepository.saveAll(validUserTokens);    }    public String generateRecoveryCodeByEmail(String email) {        User user = userRepository.findByUserEmail(email);        if (user != null) {            // Genera un número entre 1000 y 9999            int code = 1000 + random.nextInt(9000);            // Convierte el código a String            String codeStr = String.valueOf(code);            // Establece el código de recuperación en el usuario            user.setRecoveryCode(codeStr);            // Guarda el usuario con el nuevo código de recuperación            userRepository.save(user);            // Utiliza el servicio de correo electrónico para enviar el código            emailService.enviarCodigoRecuperacion(email, codeStr);            // Retorna el código de recuperación            return codeStr;        } else {            // Lanza una excepción si no se encuentra el usuario            throw new ValidationException("Usuario no encontrado con el email: " + email);        }    }    public boolean resetPassword(String email, String codigo, String newPassword) {        User user = userRepository.findByUserEmail(email);        if (user != null && user.getRecoveryCode().equals(codigo)) {            String encodedPassword = passwordEncoder.encode(newPassword); // Asegúrate de encriptar la contraseña            user.setUserPassword(encodedPassword);            user.setRecoveryCode(null); // Limpiar el código de recuperación            userRepository.save(user);            return true;        } else {            return false;        }    }    public void validateRegisterRequest(RegisterRequest registerRequest)    {        if(registerRequest.getUserFirstName()==null  ||                registerRequest.getUserFirstName().isEmpty())        {            throw new ValidationException("El nombre del usuario debe ser obligatorio");        }        if(registerRequest.getUserFirstName().length()>50)        {            throw new ValidationException("El nombre del usuario no debe exceder los 50 caracteres");        }        if(registerRequest.getUserLastName()==null || registerRequest.getUserLastName().isEmpty())        {            throw new ValidationException("El apellido del usuario debe ser obligatorio");        }        if(registerRequest.getUserLastName().length()>50)        {            throw new ValidationException("El apellido del usuario no debe exceder los 50 caracteres");        }        if (registerRequest.getUserEmail() == null || registerRequest.getUserEmail().isEmpty()) {            throw new ValidationException("El email del usuario debe ser obligatorio");        }        if (registerRequest.getUserEmail().length() > 50) {            throw new ValidationException("El email del usuario no debe exceder los 50 caracteres");        }        if (registerRequest.getUserPassword() == null || registerRequest.getUserPassword().isEmpty()) {            throw new ValidationException("La contraseña del usuario debe ser obligatorio");        }        if (registerRequest.getUserPassword().length() > 100) {            throw new ValidationException("La contraseña del usuario no debe exceder los 100 caracteres");        }    }    public void existsUserByEmail(RegisterRequest registerRequest) {        if (userRepository.existsByUserEmail(registerRequest.getUserEmail())) {            throw new ValidationException("Ya existe un usuario con el email " + registerRequest.getUserEmail());        }    }}